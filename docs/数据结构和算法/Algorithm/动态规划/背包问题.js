/* 
给定一个固定大小的背包，背包的容量为 capacity，有一组物品，存在对应的价值和重量，
要求找出一个最佳的解决方案，使得装入背包的物品总重量不超过背包容量 capacity，
而且总价值最大。本题中给出了3个物品，其价值和重量分别是 `(3,2),(4,3),(5,4)`。
括号左边为价值，右边为重量，背包容量 capacity 为5。
那么求出其搭配组合，使得背包内总价最大，且最大价值为多少？ 

背包问题有基本的理解：
物品无法拆成分数形式，如果能拆分，那就属于贪婪算法问题
不一定恰好装满背包。
装满时总价值不一定最大。
每样物品各一件
常规情况下，在表格中，价格和重量一般都是从上到下递增的。我们填表分析的时候，其实是事先默认了这种递增的关系。

*/



function knapSack(w,val,capacity,n){
    // 我们建立的递推表
    let T = []
    // i 代表第几个物品，从第0个开始
    for(let i= 0; i<n;i++){
        T[i] = [];
        // j代表每次背包容量增加1，求出不同容量的最佳组合
        for(let j = 0; j <= capacity; j++){
            if(j===0){
                // 背包容量为零 那么价值肯定为零
                T[i][j] = 0;
                continue;
            }
            // 如果物品重量都大于背包容量了肯定装不下
            if(w[i]>j){
                // 只有一个物品0，背包容量又不够
                if(i===0){
                    // 肯定价值就只能是0
                    T[0][j] = 0
                }else{
                    // i!=0时，代表的是可以使用0到i的物品组合
                    // 第i个物品无法放入 背包的价值只能是0到i-1的物品组合的最优解
                    T[i][j] = T[i-1][j]
                }
                continue;
            }
            if(i===0){
                // 只有一个物品时就只能放这个物品
                T[i][j] = val[i]
            }else{
                // 如果背包此时能够放入第i个商品，得判断放入和不放入哪个才是最优解

                // 放入物品i：剩余的容量表达式应为 j-w[i] ，剩余的容量还能产生多少价值我们已经缓存在了表里，这里我们可以直接用，就在前面的j-w[i]列，价值= T[i][j-w[i]
                // 放入物品参生的总价值公式  T[i][j] = val[i] + T[i][j-w[i]]

                // 不放入物品i：既然不放入了，与i-1时参生的价值就没有区别的，那么价值与同一列的上一行相等
                // 不放入物品产生的总价值公式 T[i][j] = T[i-1][j]

                // 比较放入和不放入产生的价值就可以确定是否放入，然后又会得到最优解(注意：这里就已经形成了动态规划的状态转移公式，而且确保了每一步规划都是最优的，直到规划到最后)
                T[i][j] = Math.max(val[i] + T[i-1][j-w[i]],T[i-1][j]);    // ?没有计算背包剩余的意思，每次有新的物品进入都相当与清空背包直接放入新物品然后比较放入是否是最优解            
            }       
        }
    }
    findValue(w,val,capacity,n,T)
    return T
}

var values = [3,4,5],
	weights = [2,3,4],
	capacity = 5,
	n = values.length;

console.log(knapSack(weights,values,capacity,n));
// console.log(knapSack([2,2,6,5,4],[6,3,5,4,6],10,5));

// knapSack无法判断我们选择了那些物品，得回溯去寻找
// findValue 主要就是通过最终坐标对比上一层是否有变化，有变化就是加入了
function findValue(w,val,capacity,n,T){         
	var i = n-1, j = capacity;                
	while ( i > 0 && j > 0 ){
        // 定位到最后一个数据，比较和包空间同大小的上一层有没有变化                         
		if(T[i][j] != T[i-1][j]){                                                 
            // 如果有变化，那么肯定是在当前层添加物品                                                                                                                                                   
            console.log('选择物品'+i+',重量：'+ w[i] +',价值：' + val[i]);         
            // 然后找加入这个物品之前容量对应的坐标                                                            
			j = j- w[i];                                    
			i--;                        
		}else{
			i--;  //如果两个值相等，这表明没有放入i物品时，往上回溯到i-1，开始下次循环
		}
    }
    //  如果能回溯到第一行，且回溯点不是0，那肯定第一个物品是加入了
	if(i == 0 ){
		if(T[i][j] != 0){ //那么第一行的物品也可以取
			console.log('选择物品'+i+',重量：'+ w[i] +',价值：' + val[i]);                                                                                                         
		}
	}
}


